# **开发小笔记**

## **算法**

### **二分查找**

- 思想：思想:取一个索引开头left,取一个索引末尾(len(队列)-1)right,让你的值跟(left + right)//2(middle)比。如果索引middle值比你查的值大,把middle赋值给right,反之把middle赋值给left。

**（1）该数组，必须是有序：**

1. 二分查找依赖的是**顺序表结构**，即**数组**。
2. 二分查找针对的是有序数据，因此只能用在插入、删除操作不频繁，一次排序多次查找的场景中。

**（2）对数据量大小有要求**：

1. 数据量太小不适合二分查找，与直接遍历相比效率提升不明显。但有一个例外，就是数据之间的比较操作非常费时，比如数组中存储的都是组成长度超过100的字符串。
2. 数据量太大也不适合用二分查找，因为数组需要连续的空间，若数据量太大，往往找不到存储如此大规模数据的连续内存空间。

**（3）一般要求找到的是某一个值或一个位置**







## Jupyter Notebook快捷键总结



| Markdown      | 功能                  |
| ------------- | --------------------- |
| m/y           | 切换状态栏            |
| -空格         | 无序列表              |
| 1.空格        | 有序列表              |
| ```python ``` | 插入python代码        |
| **代码块**    | **功能**              |
| dd            | 删除单元格            |
| L/shift+L     | 切换行号/切换所有行号 |
| shift+m       | 合并单元格            |
| ctrl+shift+-  | 拆分单元格            |
| a/b           | 插入单元格            |

### 1. Jupyter Notebook有两种mode

- Enter：进入edit模式
- Esc：进入command模式

### 2. Command命令快捷键：

- A：在上方增加一个cell
- B：在下方增加一个cell
- X：剪切该cell
- C：复制该cell
- V：在该cell下方粘贴复制的cell
- Shift-V：在该cell上方粘贴复制的cell
- L：隐藏、显示当前cell的代码行号
- shift-L：隐藏/显示所有cell的代码行号
- O：隐藏该cell的output
- DD：删除这个cell
- Z：撤销删除操作
- Y：转为code模式
- M：转为markdown模式
- R：转为raw模式
- H：展示快捷键帮助
- Shift-Enter：运行本单元，选中下个单元 新单元默认为command模式
- Ctrl-Enter 运行本单元
- Alt-Enter 运行本单元，在其下插入新单元 新单元默认为edit模式
- OO：重启当前kernal
- II：打断当前kernal的运行
- shift+上/下：向上/下选中多个代码块
- 上/下：向上/下选中代码块
- F：查找替换

### 3. Edit命令快捷键：

- Tab：代码补全
- ctrl]或Tab：缩进（向右）
- ctrl[或shift-Tab：反缩进（向左）
- ctrl A：全选
- ctrl D：删除整行
- ctrl Z：撤销





## **Python**

### **1.Pandas→mysql**

```markdown
Q: Pandas to Mysql AttributeError: ‘Timestamp‘ object has no attribute ‘translate‘
```

```python
rst['ds'] = rst['ds'].apply(lambda x: x.strftime('%Y-%m-%d %H:%M:%S'))

warn_day_hour['date_day'] = warn_day_hour['date_day'].astype(str)
```



### **2.pandas高级接口dt**

```markdown
dt.year

dt.month

dt.day

dt.hour

dt.minute

dt.second

dt.week

(dt.weekofyear和dt.week一样)分别返回日期的年、月、日、小时、分、秒及一年中的第几周
```



### **3.提取每小时，切片**

```python
for m in range(6,24):
    a=0
    for i in range(len(df)):
        if int(df.iloc[i]['计划时间']**[:2])** == m:
            a+=df.iloc[i]['承载人数']
    print(a)
```



### **4.去重**

1. 去除完全重复的行数据

data.drop_duplicates(inplace=True)

2. 去除某几列重复的行数据

data.drop_duplicates(subset=['A','B'],keep='first',inplace=True)

**subset：** 列名，可选，默认为None

**keep：** {‘first’, ‘last’, False}, 默认值 ‘first’

**first：** 保留第一次出现的重复行，删除后面的重复行。

**last：** 删除重复项，除了最后一次出现。

**False：** 删除所有重复项。

**inplace：**布尔值，默认为False，是否直接在原数据上删除重复项或删除重复项后返回副本。（inplace=True表示直接在原来的DataFrame上删除重复项，而默认值False表示生成一个副本。）



### **5.表关联**

\# 4表关联, projid

（1）多表

```python
df_merge = reduce(lambda x, y: pd.merge(x, y, on=['PROJID']), [df_1, df_2, df_3, df_4])  # PROJID*4表
```

（2）两表

```python
df_merge1 = pd.merge(df_1, df_2, how='inner')
```



### **6.删除指定列**

```python
df = df.drop(columns=['date', 'month'])
```



### **7.删除空值行**

（1）

```python
df_approve_out = df_approve_out[~(df_approve_out['anomaly_style'].isnull())] #删掉空行

df = dropna(axis=0)  # 删除有空值的行，使用参数axis=0

df=dropna(axis=1) #删除有空值的列，使用参数axis=1
```

（2）

```python
# 删除anomaly_style空值行

unique_anomaly_style = df_approve_out['anomaly_style'].astype(str).unique()

unique_anomaly_style = [i for i in unique_anomaly_style if i != '']

df_approve_out = df_approve_out[df_approve_out['anomaly_style'].isin(unique_anomaly_style)]

df = df.dropna(subset=['name','team'])
```



### **8.排序**

pandas>>>>>>>>>>>

inplace：是否修改原始DataFrame

当 **inplace = False** 时，返回为修改过的数据，原数据不变。

当 **inplace = True** 时，返回值为 None，直接在原数据上进行操作。



升：

```python
df.sort_values(by='price', inplace=True)
```

降：

```python
df.sort_values(by='price', inplace=True, ascending=False)
```

```python
data.sort_values(by='AdmissionDate')    # 日期升序
```

```python
# python>>>>>>>>>>>>>>

# sort的参数reverse 可以控制排序规则，reverse为True 时是降序， reverse为False时是升序（默认），运行如图所示的程序，进行升序排序。

a.sort(reverse=False)
```



### **9.dataframe为空**

```python
if not df.empty:

# 如果df为空，则 df.empty 返回 True，反之 返回False。

rst = rst.where(rst.notnull(), None)      # 若dataframe有空值，则转换为None写入
```



### **10.重新索引**

```python
df = df.reset_index(drop=True)
```



### **11.时间转换**

```python
df['日期'] = pd.to_datetime(df['日期'], format='%Y-%m-%d')  #转化为时间格式
```



### **12.保留两位**

```python
df_merge = df_merge.round({'wait_time': 2}) # 保留两位

df_merge = round(df_merge['wait_time'], 2) # 保留两位
```



### **13. 获取周几**

```python
df = pd.DataFrame(pd.date_range(start='2020-05-01', end='2020-06-05'))

df[1] = df[0].dt.dayofweek + 1

df.head(10)

#########################
# dt的其他常用属性和方法如下：

df['日期'].dt.day   # 提取日期

df['日期'].dt.year # 提取年份

df['日期'].dt.hour # 提取小时

df['日期'].dt.minute # 提取分钟

df['日期'].dt.second # 提取秒

df['日期'].dt.week # 一年中的第几周

df['日期'].dt.weekday # **返回一周中的星期几，0代表星期一，6代表星期天**

df['日期'].dt.dayofyear # 返回一年的第几天

df['日期'].dt.quarter # 得到每个日期分别是第几个季度。

df['日期'].dt.is_month_start # 判断日期是否是每月的第一天

df['日期'].dt.is_month_end # 判断日期是否是每月的最后一天

df['日期'].dt.is_leap_year # 判断是否是闰年

df['日期'].dt.month_name() # 返回月份的英文名称

df['日期'].dt.to_period('Q') # M 表示月份，Q 表示季度，A 表示年度，D 表示按天

df['日期'].dt.weekday_name # 返回星期几的英文 由于pandas版本问题，改变pandas版本在cmd中输入：pip install --upgrade pandas==0.25.3

Series.dt.normalize() # 函数将给定系列对象中的时间转换为午夜。
```



### **14.pop删除函数**

```python
popped_num = t1.pop(0)   

\#pop()函数，从列表取出第0个元素将其存储在popped_num，并删除
```



### **15. 空值赋0**

```python
mydf['列名']=mydf['列名'].fillna(0)
```

![img](https://docimg4.docs.qq.com/image/eCwLhH_ZoMnf8tmus0iAEA.png?w=1971&h=600)





## **MySQL**

**1.判断周几**

```mysql
select if(dayofweek(curdate()) = 1,7,dayofweek(curdate()) -1);
```

